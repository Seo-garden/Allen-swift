# 열거형

### 열거형의 기본 개념 (53강)

열거형(Enumerations)

    타입 자체를 한정된 사례(case) 안에서 정의할 수 있는 타입
    열거형을 사용하면 코드의 가독성과 안정성이 높아짐 -> 명확한 분기 처리 가능
    타입으로 만든 경우, 미리 정의해둔 타입의 케이스에서 벗어날 수 없으므로 코드의 가독성과 안장성이 높아짐
    
### 열거형의 원시값과 연관값 (54강)

열거형의 원시값은 매칭되는 기본값(정수/문자열)을 정해, 열거형을 좀 더 쉽게 활용이 가능하다.  

열거형을 선언할 때 타입을 함께 선언하는 것이 열거형의 원시값이다.

    enum Alignment: Int {       Int 가 원시타입이다.
        case left -> 0
        case center -> 1
        case right -> 2
    }
    var align = Alignment(rawValue: 0) == Alignment.left 

원시값을 사용하면 열거형을 쉽고 자유롭게 다룰 수 있다.  

생성자를 사용해서 선언할 때 nil이 나올 수도 있기 때문에 바인딩을 해줘야 한다.  

열거형의 연관값은 구체적인 추가정보를 저장하기 위해 사용, 보다 구체적인(하위의)정보를 저장 하기위해, 정의 가능

    enum Computer {
        case cpu(core: Int, ghz: Double) -> core, ghz 가 연관값 마음대로 선언이 가능하다.
    }
    1. 각 케이스 별로 상이한 특징이 있고, 그것을 저장/활용할 필요가 있을 때
    2. 개별케이스마다 저장할 형식을 따로 정의(자료형에 제한이 없음/튜플의 형태)
    3. 하나의 케이스에 서로다른 연관값을 저장할 수 있음 --> 선언시점이 아니라, 새로운 열거형 값을 생성할 때 저장

원시값과 연관값의 차이

    1. 자료형 선언 방식 : 선언하는 위치가 다름
    2. 선언 형식 : 1. 원시값 -> 2가지중 1가지 선택 / 연관값 -> 튜플의 형태로 형식 제한 없음
    3. 값의 저장 시점 : 원시값 : 선언시점 / 연관값 : 새로운 열거형 값을 생성할 때
    4. 서로 베타적 : 하나의 열거형에서 원시값과 연관값을 함께 사용하는 것은 불가능함
    
### 옵셔널 타입에 대한 정확한 이해(55강)

옵셔널 타입의 내부 구현

    enum Optional {
        case some(Int)  //구체적인 정보를 저장
        case none
    }
    
.none과 nil 은 완전히 동일하다. .none은 명시적인 열거형으로 표현한 것이고, 일반적으로 값이 없다는 의미의 nil키워드를 사용할 뿐이다.

정리.
 
    옵셔널 타입이 enum 타입으로 정의되어 있다. 타입은 내부적으로 some과 none의 케이스를 가진 타입이다. some의 케이스인 경우에는 연관 값을 통해서 구체적인 값을 다시 저장하고 있고, if let 바인딩으로 벗겨서 사용하는 것은 실제로 case 안에 값을 꺼내서 사용하는 거다.


### 열거형과 switch 문의 활용 (56강)

열거형에 대한 구체적인 처리는 switch 문과 함께 쓸 때, 사용성이 높아진다.

    switch x{
        case .left:
            print("왼쪽")
        case .right:
            print("오른쪽")
        case nil:
            print("해당없음")
    }
    
    열거형은 한정된 사례(case)로 만든 타입이고, 스위치문은 표현식에 대한 분기처리에 최적화 되어 있기 때문에, 활용에 적합 + switch 문은 옵셔널 쉽게 사용 기능 제공
    
### 열거형에 연관값이 있는 경우 (57강)

특정 케이스만 다루기 위해서 if 문이나 반복(for)문으로 사용 가능하다

    switch chip {
        case Computer.hardDisk(gb: let gB):
            print("\(gB)기가 바이트 하드디스크임")
        default:
            break
    }
    -> if문으로 변환
    if case Computer.hardDisk(gb : let gB) = chip {
        print("\(gB)기가 바이트 하드디스크임") 
    }   //콜론 대신 할당이 필요하다.
    
    let chiplists: [Computer] = [.cpu(core: 4, ghz: 3.0)]
    -> for문으로 변환
    for case let .cpu(core: c, ghz: g) in chiplists {
        print("\(c) \(h)")      
    } 배열중에서 특정 케이스만 뽑아서 활용이 가능하다.

### 옵셔널 패턴 (58강)

열거형 케이스 패턴 -> 옵셔널 패턴

    switch a {
        case .some(let z): -> case let z?: //.some을 조금 더 간소화 하는 방법
            print(z)
        case .none:
            print("nil")
    }
    switch 문에서 .some문장을, (.some도 생략가능) 쉽게 작성할 수 있다.
    
### 열거형의 @unknown 키워드 (59강)

@unknown 키워드를 붙이면 switch문에서 열거형의 모든 케이스를 다루지 않는 경우, 스위치문에서 모든 열거형의 케이스를 다루지 않았다고 경고를 통해 알려준다. 개발자의 실수를 줄여준다.
