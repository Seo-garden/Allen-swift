# 열거형

### 열거형의 기본 개념 (53강)

열거형(Enumerations)

    타입 자체를 한정된 사례(case) 안에서 정의할 수 있는 타입
    열거형을 사용하면 코드의 가독성과 안정성이 높아짐 -> 명확한 분기 처리 가능
    타입으로 만든 경우, 미리 정의해둔 타입의 케이스에서 벗어날 수 없으므로 코드의 가독성과 안장성이 높아짐
    
### 열거형의 원시값과 연관값 (54강)

원시값의 활용

    숫자 또는 문자열과 매칭시켜 자유롭게 활용이 가능하다

열거형의 연관값

    열거형의 연관값은 구체적인 추가정보를 저장하기 위해 사용
    enum Computer{ 보다 구체적인(하위의)정보를 저장하기위해, 정의가능
        case cpu(core: Int, ghz: Double)
    }
    ex) let myChips1 = Computer.cpu(core: 8, ghz: 3.5)

원시값과 연관값의 차이

    1. 자료형 선언 방식 : 선언하는 위치가 다름
    2. 선언 형식 : 1. 원시값 -> 2가지 중 1가지 선택 / 2. 연관값 -> 튜플의 형태로 형식 제한 없음
    3. 값의 저장 시점 : (원시값: 선언지점 / 연관값 : 새로운 열거형 값을 생성할 때)
    4. 서로 베타적 : 하나의 열거형에서 원시값과 연관값을 함께 사용하는 것은 불가능하다.
    
    
| 구분 | 원시값 | 연관값 | 
|------|------|------|
| 사용 목적 | 열거형 타입의 각 케이스에 정수 또는 문자열을 매칭시켜, 타입을 생성하거나 다룰떄 조금 더 편하게 사용 | 열거형 타입의 각 케이스의 카테고리에는 해당하지만, 보다 구체적인 정보를 저장해서 사용하려고 할때 |
| 선언 방법 | 선언 타입이 제한 - Int, String 주로 사용 | 선언 타입에 제한없이 자유롭게 정의 가능 |
| 값의 저장 | 열거형의 선언 시점(선언시에 case 마다 값이 매칭) | 인스턴스 생성 시 |
| 값의 변경 | 선언시에 정의 개념이기에 당연히 불가능 | 하나의 케이스에 서로 다른 값들을 저장 가능 |
| 주의점 | 하나의 열거형에서 원시값과 연관값을 동시에 사용하는 것은 불가능 |

### 열거형과 switch 문 (56강)

열거형에 대한 구체적인 처리는 switch문과 함께 쓸 때, 사용성이 높아진다

    열거형은 한정된 사례로 만든 타입이고, switch문은 표현식에 대한 분기처리에 최적화 되어 있기 때문에, 활용에 적합
    
switch 문에서 옵셔널 열거형 타입을 사용할 때, 벗기지 않아도 내부값 접근가능

    열거형은 한정된 사례로 만든 타입이고, 스위치문은 표현식에 대한 분기처리에 최적화 되어 있기 때문에, 활용에 적합 + 스위치문은 옵셔널 쉽게 사용 기능 제공

### 열거형의 연관값이 있는 경우 (57강)

연관값이 있는 경우 

    switch chip {
        case Computer.hardDisk(gb: let gB):
            print("\(gB)기가 바이트 하드디스크임")
        default:
            break;
    }
    -> if문에서도 case 문을 쓸 수 있다. 
    if case Computer.hardDisk(gb: let gB) = chip {
        print("\(gB)기가 바이트 하드디스크임")
    }

### 옵셔널 패턴 (58강)


