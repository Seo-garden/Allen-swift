### 속성과 메서드 (90강)
> [!NOTE] 구조체와 클래스 속성과 메서드를 가진다.(추후에 구체적으로 살펴본다.)
> - 변수 -> 속성(property)
> 	- 구조체/클래스의 변수(아래는 포함요소)
> 		- 저장 속성, 지연(lazy) 저장 속성
> 		- 계산 속성
> 		- 타입 속성
> 		- 속성 감시자
> - 함수 -> 메서드(method)
> 	- 구조체/클래스의 함수(아래는 포함요소)
> 		- 인스턴스 메서드
> 		- 타입 메서드
> 		- 서브스크립트
> 		- 생성자(지정생성자, 편의생성자, 필수 생성자, 실패가능생성자)
> 		- 소멸자(deinitializer)

### 저장 속성 (91강)
*값이 저장되는 일반적인 속성(변수)을 저장 속성이라고 함*

	struct bird { name 과 weight 가 저장속성이다.
	    var name : String
	    var weight : Double
	
	    init(name: String, weight: Double) {
	        self.name = name
	        self.weight = weight
	    }
	}

> [!WARNING] 저장 속성의 주의점
> - 구조체, 클래스가 동일하게 저장 속성을 가질 수 있다.
> - let 또는 var 로 선언 가능(만약 저장 속성을 let 으로 선언하면 바꿀 수 없음)
> - ⭐️저장 속성은 각 속성자체가 고유의 메모리 공간을 가진다.
> - 초기화 이전에 값을 가지고 있거나, 이니셜라이저를 통해 값을 반드시 초기화 해야 한다.
> - 열거형 자체는 저장속성 어떤 데이터를 가질 수 있는 저장속성을 선언할 수 없다.
### 지연 저장 속성 Lazy Stored Properties (92강)
*lazy 로 선언된 프로퍼티를 접근한 순간 메모리를 할당한다. 메모리공간을 만들지도 않는다.*
> [!NOTE] ⭐️지연저장의 의미
> 저장속성은 "해당 저장 속성"의 초기화를 지연시키는 것
> 즉, 인스턴스가 초기화되는 시점에 해당 속성이 값을 갖고 초기화되는 것이 아니라(메모리 공간과 값X) 해당 속성(변수)에 접근하는 순간 (해당하는 저장 속성만) 개별적으로 초기화됨.
> *따라서 상수로 선언이 불가하고 변수로 선언이 가능하다.*

	struct  bird {
	    var name : String
	    lazy var weight : Double = 0.0
	    지연저장으로 선언을 하게 될 경우 이니셜라이저를 사용할 수 없기 때문에 선언함과 동시에 초기화를 해줘야 한다.
	    init(name: String) {
	        self.name = name	        
	    }
	}
	var bird1 = bird(name: "공작")
	bird1.weight = 0.2 // 프로퍼티 접근하는 순간 메모리공간이 생기고 숫자가 저장된다.

> [!TIP] ⭐️지연 저장 속성을 사용하는 이유
> - 메모리 공간을 많이 차지하고 초기화를 지연시킬 때(메모리 낭비를 막기 위함)
> - 다른 저장 속성을 이용해야 할 때(다른 저장 속성에 의존할 때)
> 	- ex) lazy var b : Int = {return a * 10}() --> 여기서 b 라는 값은 항상 a의 값에 의존하기 때문에 a가 먼저 메모리에 존재해야만 b 를 찍어낼 수 있다.
### 계산 속성을 다루기 전에, 함수 복습 (93강)

	func sum(_ a: Int, _ b: Int) -> Int{
	    var c = a + b
	    return c	
	}
	var x = sum(3, 4)

> [!NOTE] 컴퓨터가 일하는 방식
>플레이그라운드에서 함수를 실행할 때, main() 함수에 둘러싸여있다. 코드영역에 컴파일 되어 존재하게 된다. sum() 이라는 함수가 한줄한줄 쪼개서 저장이 되고, a 변수를 만들고 b 변수를 만들고 컴파일된다. main()함수가 실행되면 Stack 영역에 스택프레임을 만들고 함수를 실행하게 되면 복귀주소를 저장하고 함수의 메모리 주소를 가서 함수를 실행한다. 함수가 종료되면 스택프레임도 소멸된다. 
### 메서드의 메모리 구조의 이해 (94강)

	class Dog {
	    var name : String
	    var weight : Int
	    init(name: String, weight: Int) {
	        self.name = name
	        self.weight = weight
	    }
	    func sit(){print("\(self.name)이 앉아있습니다.")}
	}
	var bori = Dog(name: "보리", weight: 10)
> [!NOTE] 메모리구조
> 저장속성은 Heap에 저장된다. 메서드는 Code 영역에서 실행할지의 명령어묶음인데 명령어들이 모여서 메모리주소를 차지한다. 보리의 sit()을 실행하면 Code 영역에서 보리를 찾아가고 Dog() 의 주소가 가리키고 있기 때문에 Dog의 주소에서 연결되어 있는 함수를 찾아간다. sit() 함수의 메모리주소를 통해 명령어들을 하나하나 실행하면서 스택프레임을 만들고 메서드가 동작한다. (주교재를 보는 것이 이해가 더 빠르다.)  
구조체의 경우에는 실제로 함수 메모리 주소에 직접 접근하기 때문에 class 처럼 찾아가는 과정이 없다. 이런식으로 동작하기 때문에 구조체가 class 보다 훨씬 빠르게 동작한다.
### 계산 속성 Computed Properties(95강)
> [!NOTE] ⭐️계산 속성 (자바의 getter setter)
> - 계산속성의 경우 get{} / set{} 으로 구성되고 감싸고 있는 변수의 타입이 존재해야 한다. (선언 시 let 으로 선언할 수 없다)
> - get{} 메서드의 경우 필수로 선언되어야 하고 return 값이 존재해야 한다. 하지만 return타입을 쓰진 않는다.
> - 개발자의 입장에서 값을 얻기위한 행동은 get{} 이고, 값을 세팅하기 위한 set{} 이다.
>  - set{} 메서드는 선택적으로 구현하지 않아도 된다. set(파라미터){}를 추가할 수 있다. 추가하지 않을 경우 파라미터 대신 newValue 를 사용해야 한다.

> [!TIP] 근데 set{} 을 구현안할꺼면 함수를 쓰지. 굳이 이렇게 하는 이유가 있나 ?
>선언하는 변수가 애플의 프레임워크도 이런식으로 구현되어 있는 경우가 많다. 그리고 get{} 사용하는 것이 간결하고 일반적으로 선호된다. 따라서 읽기전용인 경우 get{} 을 사용하는 것이 일반적이다.

	class MyComProperty {
	    private var _myValue = 0
	    var myValue: Int {
	        set{
	            _myValue = newValue > 100 ? 100 : newValue
	        } get {
	            return _myValue
	        }
	    }
	}
	var myComProperty = MyComProperty()
	myComProperty.myValue = 100
	print("myValue: \(myComProperty.myValue)")
	myComProperty.myValue = 200
	print("myValue: \(myComProperty.myValue)")
### 계산 속성 이해하기 / 메모리 구조 (96강)
> [!Tip] 메서드가 아닌, 속성방식으로 구현하면 어떤 장점 ?
> - 관련이 있는 두가지 메서드(함수)를 한번에 구현할 수 있다.
> - 외부에서 보기에 속성이름으로 설정가능하므로 한번에 구현할 수 있다.
> - ⭐️계산 속성의 겉모습은 속성(변수)형태를 가진 메서드(함수)
> - 메서드이기 때문에 인스턴스 메모리 공간을 가지지 않고, 해당 속성에 접근했을 때 다른 속성에 접근해서 계산한 후, 계산 결과를 리턴하거나 세팅하는 메서드이다.

> [!WARNING] 계산 속성의 주의점
> - 항상 변하는 값이므로 변수로 선언을 해야 한다(상수로 선언이 불가하다)
> - 자료형 선언을 해야한다(타입추론이 불가, return필수)
> - get{}을 반드시 선언해야 한다(set{} 선택사항)

> [!NOTE] 메모리 공간에서의 계산속성
> - get{} set{} 메서드가 데이터 공간에서 따로 존재한다. 
> - 실질적인 메서드이기 때문에 인스턴스에 메모리 공간을 갖지 않는다. 
> - 항상 메서드의 실행은 스택프레임에서 움직인다. 
### 타입속성 Type Properties (97강)
*static(고정적인/고정된) 키워드를 추가한 저장 속성*
> [!NOTE] 저장 타입 속성과 계산 타입 속성
>저장 타입 속성 ex) static let pi = 3.1415 (참고.playground)
> - 모든 인스턴스가 동일하게 가져야하는 보편적인 속성이거나, 모든 인스턴스가 공유해야하는 성격에 가까운 저장속성을 저장 타입 속성으로 선언
> - static 키워드를 사용. (상속 시) 재정의 불가(메서드만 상속이 가능 - class 키워드 사용 불가)
> - let / var 둘다 선언이 가능하다(저장 타입 속성)
> - 항상 초기값이 필요(생성자에 의한 값 설정 과정X)
> - 자체적인 지연 속성의 성격으로 호출시 메모리 할당
>
>계산 타입 속성 ex) static var multiPi: Double{return pi * 2}
>
> - 값을 직접 저장하지 않고, 계산된 값을 반환하고 싶을 때 사용합니다. 매번 속성에 접근할 때마다 계산이 이루어집니다.
> - (상속 시)재정의 가능(class 키워드 사용 시 에만)
> - static 또는 class 키워드 사용
> - var 키워드만 사용 가능
> - 메서드 이기 때문에 타입에 메모리 공간이 할당되어 있지 않음(계산 속성)
### 계산 타입 속성 (98강)

> [!NOTE] 저장 타입 속성
> - 일반 저장속성은 인스턴스를 생성할 때, 생성자에서 모든 속성 초기화를 완료, 그리고 해당 저장 속성은 각 인스턴스가 가진 고유한 값
> - ⭐️ 저장 타입 속성은 생성자가 따로 없기 때문에, 타입 자체에 속한 속성이기 때문에 항상 기본값이 필요하다.
> - ⭐️ 지연 속성의 성격을 가진다(lazy 선언할 필요가 없다)

> [!WARNING] 주의점
> - 타입 속성 ==> class, struct, enum 에 모두 추가할 수 있음
> - 변수 혹은 상수 선언 가능
> - 타입 속성은 즉 인스턴스에 속한 속성이 아니기 때문에 인스턴스 이름으로는 접근 불가

> [!TIP] 어떤 경우에 타입 속성을 선언해야 하나?
> - 모든 인스턴스가 동일하게 가져야 하는 속성이거나, 공유해야 하는 성격에 가까울 때

> [!NOTE] 상속에서의 재정의(overriding)
> - 저장 타입 속성 --> 상속에서 하위클래스에서 재정의 불가능(인스턴스의 경우 저장 속성은 고유의 틀이기 때문에 건드릴 수 없음)
> - 계산 타입 속성 --> 상속에서, 상위클래스에서 class키워드를 붙인 경우, 재정의 가능
### 속성 감시자 Property Observer (99강)
> [!NOTE] 기본적으로 "속성 감시자" 라는 이름이지만, 성격은 메서드 -> 저장 속성 감시
> - 저장 속성이 변하는 시점을 관찰
> - 저장 속성이 변하는 순간 --> method 가 호출됨
> - willSet은 값이 변경되기 직전에 호출된다.
> - didSet의 경우 값이 변경되고 나서 호출된다.

> [!NOTE] 속성 감시자
> - 클래스나 구조체 열거형에 동일하게 적용
> - 일반적으로 willSet or didSet 중에서 한가지만 구현(실제 프로젝트에선 didSet을 많이 사용)

> [!TIP] 속성감시자(willSet or didSet) 가 왜 필요한데 ?
> - 속성이 변하는 시점을 알아차리도록 시점에 제약을 만드는 코드를 짜기는 어려움이 있다 --> 그래서 실제 앱을 만들고 활용할 때 좋은 수단
> - 변수가 변하면, 변경 내용을 반영하고 싶을 때 (업데이트)

> [!WARNING] 주의점
> - ⭐ 속성 감시자를 추가 가능한 경우
> 	- 저장 속성(원래, 상속한 경우 둘다 가능)
> 	- 계산 속성(상속해서 재정의하는 경우에만 가능)
> - 계산 속성의 경우, 속성 관찰자를 만드는 대신 계산 속성의 set 블록에서 값 변경을 관찰할 수 있기 때문에 재정의(상속)가 아닌 본래의 계산 속성에는 추가 불가
> - 지연저장 속성에 안됨

> [!NOTE] 정리
> - 저장속성 자체는 var 로만 선언 가능(let 은 관찰필요 없음, 지연저장 속성은 관찰 안됨)
> - 자료형을 선언하는 것은 일반 변수와 동일(기본값을 넣으면 형식 추론 방식 가능함)
> - 저장 속성의 변화시점을 관찰하는 실질적 메서드(타입/인스턴스 둘다 가능은 하지만 일반적으로 타입 저장 속성에다가 구현하진 않고 인스턴스에 구현)
> - willSet or didSet 중에서 한가지만 구현
> - 변수가 변하면, 업데이트 하려는 패턴을 구현할 때 사용
> - 속성 감시자 추가 가능한 경우 (인스턴스 속성)
> 	- 저장 속성(상속한 저장속성은 재정의 불가, 감시자 추가는 가능)
> 	- 상속한 계산 속성을 재정의 속성관찰자 추가 가능(단순 메서드 추가일뿐), 본래의 계산속성에는 setter에서 값의 변경을 관찰가능 하므로 추가불가 라고 외우지 말고 파악만
### 인스턴스 메서드 (100강)
> [!NOTE] 인스턴스 메서드
> - 메서드이기 때문에 인스턴스에 메모리 공간이 할당되어 있지 않음
> - 메서드 접근 시, 인스턴스 이름으로 접근해야 함-> instance.method()
> - 메서드 실행시, 스택프레임을 만들고 인스턴스의 데이터를 사용 -> 메서드 종료 시 스택프레임이 사라짐
> - ⭐️ 값타입(구조체, 열거형)에서 기본적으로 인스턴스 메서드 내에서 속성을 수정할 수 없다. 수정하려면 mutating 키워드를 붙이면 속성 수정 가능해진다(⭐️클래스와 구조체의 차이) 

*오버로딩이란 ? 하나의 함수 이름에 여러가지 함수를 붙일 수 있다* 
### 타입 메서드 (101강)

> [!NOTE] 타입 메서드
> - 메서드이기 때문에 메모리 공간을 할당되어 있지 않음
> - 인스턴스에 속한 속성이 아니고, 타입자체에 속한 속성이기에 내/외부에서 Type.method() 로 접근해야함
> - 메서드 실행시, 스택프레임을 만들고 타입 데이터를 사용 -> 메서드 종료시 스택프레임 사라짐
> - 타입에 해당하는 보편적인 동작의 경우
> - static or class 키워드 사용(static 키워드로 상속시 재정의 불가/class 상속시 재정의 가능)
### 서브스크립트 (102강)

> [!NOTE] subscript
> 대괄호는 사실, 특별한 형태의 메서드 호출 역할 -> 배열과 딕셔너리에서는 불가능하지만, 메서드를 직접 구현도 가능하다. get{} set{} 구현해서 만들 수 있다.
> - 함수의 구현이 특별한 키워드인 subscript 로 명명됨
> - 메서드이기 때문에 인스턴스에 메모리 공간이 할당되어 있지 않음
> - 메서드 접근 시, 인스턴스 이름으로 접근해야 함 -> 인스턴스[파라미터] (특별한 형태이다)
> - 메서드 실행 시, 스택프레임을 만들고 필요한 데이터를 사용 -> 메서드 종료시 스택프레임 사라짐
> - 파라미터 2개이상도 구현가능하긴 함(Argument Label 을 따로 사용 안함)
> - get블록만 선언하면 읽기전용 계산속성이 된다(필수 구현)
> - set블록은 선택적으로 구현할 수 있다
> - set블록에서 기본 파라미터 newValue가 제공됨
>   
> 타입 서브스크립트
> - 서브스크립트 메서드 앞에 static or class 키워드만 붙이면 됨

> [!TIP] 서브스크립트를 왜 쓰는데?
> 인스턴스를 배열이나 딕셔너리처럼 사용할 수 있어서 코드가 더 직관적이고 간결하게 만들 수 있다
### 접근제어 / 싱글톤 패턴 (103강)

> [!TIP] ⭐️접근 제어가 필요한 이유
> 외부에서, private 으로 선언된 속성/메서드에 접근불가 하므로 코드 내부의 세부 구현 내용을 숨기는 것이 가능하다(=은닉화)
> - 애플이 자신들이 원하는 코드를 감출 수 있음
> - 코드의 영역을 분리시켜서, 효율적 관리 가능
> - 컴파일 시간이 줄어듬(컴파일러가, 해당 변수가 어느범위에서만 쓰이는지를 인지 가능)

*⭐️싱글톤패턴 : 메모리상에 유일하게 하나만 존재하는 객체를 설계하는 방식 / 한번 생성된 이후에는 앱이 종료될 때 까지 유일한 객체로 메모리에 상주*

> [!Tip] 싱글톤패턴을 사용하는 이유 
> 앱 구현시에, 유일하게 한개만 존재하는 객체가 필요한 경우 
> ex) static let 상수명 = class이름() (데이터 영역에 유일한 객체의 주소가 담겨있다)
private init() {} 을 선언하면 새로운 객체 추가적 생성이 불가하게 막는것이 가능하다(선언하다)


