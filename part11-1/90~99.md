### 속성과 메서드 (90강)
> [!NOTE] 구조체와 클래스 속성과 메서드를 가진다.(추후에 구체적으로 살펴본다.)
> - 변수 -> 속성(property)
> 	- 구조체/클래스의 변수(아래는 포함요소)
> 		- 지연속성, 지연(lazy) 저장 속성
> 		- 계산 속성
> 		- 타입 속성
> 		- 속성 감시자
> - 함수 -> 메서드(method)
> 	- 구조체/클래스의 함수(아래는 포함요소)
> 		- 인스턴스 메서드
> 		- 타입 메서드
> 		- 서브스크립트
> 		- 생성자(지정생성자, 편의생성자, 필수 생성자, 실패가능생성자)
> 		- 소멸자(deinitializer)

### 저장 속성 (91강)
값이 저장되는 일반적인 속성(변수)을 저장 속성이라고 함

	struct bird { name 과 weight 가 저장속성이다.
	    var name : String
	    var weight : Double
	
	    init(name: String, weight: Double) {
	        self.name = name
	        self.weight = weight
	    }
	}

> [!WARNING] 저장 속성의 주의점
> - 구조체, 클래스가 동일하게 저장 속성을 가질 수 있다.
> - let 또는 var 로 선언 가능(만약 저장 속성을 let 으로 선언하면 바꿀 수 없음)
> - ⭐️저장 속성은 각 속성자체가 고유의 메모리 공간을 가진다.
> - 초기화 이전에 값을 가지고 있거나, 이니셜라이저를 통해 값을 반드시 초기화 해야 한다.
> - 열거형 자체는 저장속성 어떤 데이터를 가질 수 있는 저장속성을 선언할 수 없다.
### 지연 저장 속성 Lazy Stored Properties (92강)
lazy 로 선언된 프로퍼티를 접근한 순간 메모리를 할당한다. 메모리공간을 만들지도 않는다.

	struct  bird {
	    var name : String
	    lazy var weight : Double = 0.0
	    지연저장으로 선언을 하게 될 경우 이니셜라이저를 사용할 수 없기 때문에 선언함과 동시에 초기화를 해줘야 한다.
	    init(name: String) {
	        self.name = name	        
	    }
	}
	var bird1 = bird(name: "공작")
	bird1.weight = 0.2 // 프로퍼티 접근하는 순간 메모리공간이 생기고 숫자가 저장된다.

> [!NOTE] ⭐️지연저장의 의미
> 저장속성은 "해당 저장 속성"의 초기화를 지연시키는 것
> 즉, 인스턴스가 초기화되는 시점에 해당 속성이 값을 갖고 초기화되는 것이 아니라(메모리 공간과 값X) 해당 속성(변수)에 접근하는 순간 (해당하는 저장 속성만) 개별적으로 초기화됨.
> 따라서 상수로 선언이 불가하고 변수로 선언이 가능하다.

> [!NOTE] ⭐️지연 저장 속성을 사용하는 이유
> - 메모리 공간을 많이 차지하고 초기화를 지연시킬 때(메모리 낭비를 막기 위함)
> - 다른 저장 속성을 이용해야 할 때(다른 저장 속성에 의존할 때)
> 	- ex) lazy var b : Int = {return a * 10}() --> 여기서 b 라는 값은 항상 a의 값에 의존하기 때문에 a가 먼저 메모리에 존재해야만 b 를 찍어낼 수 있다.
### 계산 속성을 다루기 전에, 함수 복습 (93강)
함수는 일을 할 수 있는 명령어의 묶음
적는 것 보다 주교재 그림 참고.
### 메서드의 메모리 구조의 이해 (94강)

	class Dog {
	    var name : String
	    var weight : Int
	    init(name: String, weight: Int) {
	        self.name = name
	        self.weight = weight
	    }
	    func sit(){print("\(self.name)이 앉아있습니다.")}
	}
	var bori = Dog(name: "보리", weight: 10)
> [!NOTE]
> 저장속성은 Heap에 저장된다. 메서드는 Code 영역에서 실행할지의 명령어묶음인데 명령어들이 모여서 메모리주소를 차지한다. 보리의 sit()을 실행하면 Code 영역에서 보리를 찾아가고 Dog() 의 주소가 가리키고 있기 때문에 Dog의 주소에서 연결되어 있는 함수를 찾아간다. sit() 함수의 메모리주소를 통해 명령어들을 하나하나 실행하면서 스택프레임을 만들고 메서드가 동작한다. (주교재를 보는 것이 이해가 더 빠르다.)  
구조체의 경우에는 실제로 함수 메모리 주소에 직접 접근하기 때문에 class 처럼 찾아가는 과정이 없다. 이런식으로 동작하기 때문에 구조체가 class 보다 훨씬 빠르게 동작한다.
### 계산 속성 Computed Properties(95강)

