### 스위프트의 메모리 관리 모델 (155강)
*클래스와 클로저를 제외한 거의 모든 것은 Stack 영역에 저장. 클래스와 클로저는 Heap 영역에 저장되는데, 주소는 Stack 영역에 저장한다.*
> [!NOTE] 메모리 구조
> - Heap 영역에 할당되는 데이터는 관리를 해야하지만, 메모리에서 해제가 됨
> - 할당이 해제되지 않으면 메모리 누수 현상이 발생해서 앱이 꺼지는 상황이 발생할 수 있다.
### ARC 모델 (156강)
*스위프트의 경우, 컴파일러가 실제로 retain 할당, release 해제 코드를 삽입해준다. 메모리 관리 코드를 자동으로 추가해줌으로써, 프로그램의 메모리 관리에 대한 안정성 증가*
> [!NOTE] ARC모델의 기반 : 소유정책과 참조카운팅
> - 소유정책 : 인스턴스는 하나이상의 소유자가 있는 겨우 메모리에 유지됨(소유자가 없으면, 메모리에서 제거)
> - 참조카운팅 : 인스턴스(나)를 가르키는 소유자수를 카운팅

*쉽게 말하면 인스턴스를 가르키고 있는 RC 가 1 이상이면 메모리에서 유지되고, 0이면 메모리에서 제거됨*
### 강한 참조 사이클과 메모리 누수(157강)
*객체가 서로를 참조하는 강한 참조 사이클로 인해 변수의 참조에 nil 을 할당해도 메모리 해제가 되지 않는 메모리 누수의 상황이 발생*
> [!NOTE] 메모리 누수의 해결 방안
> RC 를 고려하여, 참조 해제 순서를 주의해서 코드 작성 ==> 신경쓸 것이 많음/실수 가능성 
> - Weak Reference (약한 참조)
> - Unowned Reference (비소유 참조)

> [!NOTE] 강한 참조 싸이클로 인한 메모리 누수 해결방안
> 공통점 : 가르키는 인스턴스의 RC의 숫자가 올라가지 않음(인스턴스 사이의 강한 참조를 제거), weak/unowned 로 선언한 변수를 통해 인스턴스에 접근은 가능하지만, 인스턴스를 유지시키는 것은 불가능

|  | 약한 참조 | 비소유 참조 |
| ---- | ---- | ---- |
| 방 식 | weak | unowned |
| 예 시 | weak var pet : Dog? (nil 자동 할당) | unowned var pet : Dog? (옵셔널로 선언가능, 하지만 nil 자동 할당 X) |
| 차이점 | 소유자에 비해, 보다 짧은 생명주기를 가진 인스턴스를 참조할 때 주로 사용(인스턴스가 nil 로 확인가능, nil인 경우 작업을 중단하는 것 가능) | 소유자 보다 인스턴스의 생명주기가 더 길거나, 같은 경우에 사용(인스턴스 nil로 확인 불가능, 실제 인스턴스가 해제되었다면 에러 발생) | 
슬라이드 738 참고. 주의점.
*unowned 사용 시 한번 더 고려해야 할 것이 있기 때문에, 실제로는 weak 키워드를 사용하는 약한 참조를 더 많이 사용한다.*
### 클로저와 메모리 관리 (158강)
> [!NOTE] 캡처현상
> 클로저는 (클로저의 주기동안 사용이 필요없어질 때 까지) Heap 영역에 존재해야 하고, 클로저 내부에서 외부에 존재하는 변수를 계속 사용해야 하기 때문에 캡쳐 현상이 발생

> [!Tip] 캡처리스트를 사용하는 이유 
> - 값 타입은 값을 복사/캡처(외부적인 요인에 의한 값 변경 방지)
> - 참조타입은 캡처리스트 내에서 (메모리 주소를 캡처) weak/unowned 참조 선언 가능(강한 참조 해결 가능)

> [!Tip] 캡처현상 vs 캡처리스트
> - 값 캡처의 경우 클로저 외부에 존재하는 밸류타입의 참조(변수 주소)를 캡처함
> - 캡처리스트의 경우 클로저 외부에 존재하는 밸류타입의 값을 복사해서 사용(외부요인에 의해 해당 값의 변경을 방지할 때 사용)
### 참조 타입 캡처와 캡처리스트 (159강)
> [!Tip] 참조 타입 캡처 vs 캡처리스트
> - 참조 타입 캡처의 경우 클로저 외부에 존재하는 참조타입의 참조(변수 주소)를 캡처함(외부요인에 의해 해당 값이 변했을때도 계속 참조)
> - 클로저 외부에 존재하는 참조타입의 주소값을 복사해서 사용(외부요인에 의해 해당 인스턴스의 해제를 방지할 때 사용). 즉, 가르키는 인스턴스의 RC를 올라가게 함으로써, 메모리에서 해제될 가능성을 방지

*슬라이드 740 참고. 사용 정리*
### 일반적인 클로저의 사용 (160강)
플레이그라운드 참고.
### 메모리 누수의 사례 (161강)
플레이그라운드 참고.
### 강한 참조 사이클과 메모리 누수 (162강)
*강한 참조 해결 : 캡처리스트 + weak/unowned* 