### 동기/비동기 개념에 대한 직관적인 이해
> [!NOTE] 비동기 Async
> 작업을 다른 쓰레드에서 하도록 시킨 후, 그 작업이 끝나길 기다리지 않고 다음일을 진행한다(기다리지 않아도 다음 작성을 생성할 수 있다.)

> [!NOTE] 동기(Sync)
> 작업을 다른 쓰레드에서 하도록 시킨 후, 그 작업이 끝나길 기다렸다가 다음 일을 진행한다.(기다렸다가 다음 작업을 생성할 수 있다.)

> [!Tip] 비동기가 필요한 이유는?
> 서버와의 통신(네트워크 작업), 혹은 파일 다운로드 같은 것이 있다.

> [!NOTE] 직렬(Serial)처리
> 분산처리 시킨 작업을 "다른 한개의 쓰레드에서" 처리 -> 순서가 중요한 작업을 처리할 때 사용

> [!NOTE] 동시(Concurrent)처리
> 분산처리 시킨 작업을 "다른 여러개의 쓰레드에서" 처리 -> 각자 독립적이지만 유사한 여러 개의 작업을 처리할 때 사용(중요도나 작업의 성격 등)

> [!Tip] 동시성이 왜 필요할까?
> 성능/반응성, 최적화 를 위해 일을 다른쓰레드로 처리하기 위해
### 동시성(Concurrency) 프로그래밍 - 비동기 프로그래밍에 대한 이해 (173강)
> [!Tip] 비동기 프로그래밍이 필요한 이유
> 만약 비동기처리를 하지 않았다면 화면을 내릴 때 테이블뷰를 스크롤할 때 마다 버벅거리기 때문이다.
 
기본적으로 1번 쓰레드(메인 쓰레드)에서 일한다. 
> [!NOTE] 앱의 시작과정과 동작원리
> ![[Pasted image 20240217203543.png]]
> 아이콘 클릭 -> main() 실행 -> UIKit 이 관리하는 UIApplicationMain() 객체를 생성 -> 화면 준비를 하고 앱을 시작할 때 런루프를 생성
> ![[Pasted image 20240217203823.png]]
> 사용자가 터치를 한다거나, 두번터치를 하는 것을 하나의 이벤트라고 인지하는데, 이벤트하나하나를 쌓아서 무한루프로 던진다. 앱의 객체로 던져서 함수를 동작하게 한다. 이 행위가 반복된다.
> - 정리 : 앱이 시작될 때 앱을 담당하는 메인 런루프(반복문)가 생기고, 이벤트 처리를 담당 -> 어떤 함수를 실행시킬 것인지 선택/실행, 함수 등의 실행의 결과를 화면에 보여줘야함 -> 화면 다시 그림(항상은 아니고, 화면을 다시 그리는 일이 필요할 때) 

메인쓰레드는 1초에 60번 화면을 다시 그려야 하는 역할을 하기 때문에 너무 오래 걸리는 작업들을 시키면 안된다. 그래서 분산처리를 해야 하는데 이를 비동기처리/동시성 프로그래밍이라고 한다.
> [!NOTE] 동시성 처리
> 작업(Task)을 대기행렬(Queue)에 보내기만 하면, iOS가 알아서 여러쓰레드로 나눠서 분산처리(동시적 처리)를 한다. 우리의 할 일은 작업(Task)을 큐(Queue)로 보내기만 하면 된다.

> [!NOTE] DispatchQueue
> - 직접적으로 쓰레드를 관리하는 개념이 아닌, 대기열(Queue)의 개념을 이용해서 작업을 분산처리하고, OS 에서 알아서 쓰레드 숫자(갯수)를 관리
> - (쓰레드 객체를 직접 생성시키거나 하지 않는)쓰레드보다 더 높은 레벨/차원에서 작업을 처리
> - 메인쓰레드가 아닌 다른 쓰레드에서 오래걸리는 작업들과 같이 작업들이 쉽게 비동기적으로 동작하도록 함

동시성은 비동기를 포함할 수 있지만, 비동기는 동시성을 포함할 순 없다⭐️
동기작업은 한 작업이 다른 작업을 기다리는 반면에, 직렬은 여러 작업을 순차적으로 실행되지만, 다른 쓰레드에서 실행 될 경우에는 병렬로 실행될 수 있다.
### 동기 비동기의 개념 (174강)
> [!NOTE] 비동기 vs 동기의 개념
> ![[Pasted image 20240217213046.png]]
### 직렬과 동시의 개념 (175강)
> [!NOTE] 직렬(Serial) vs 동시(Concurrent)의 개념
> ![[Pasted image 20240217214235.png]]

> [!Tip] 분산처리 하려는 것이면 무조건 Concurrent가 무조건 좋아보이는데 Serial 가 왜 필요할까?
> 순서가 중요한 작업을 처리할 때 사용한다. 위의 그림 참고.
### GCD의 개념 및 종류 (176강)
> [!NOTE] 디스패치큐에 대해서
> ![[Pasted image 20240217225004.png]]
품질이 높은게 무조건 일을 더 먼저 끝낸다는 아니다. 먼저 끝날 수 있는 우선순위를 배치하는 것이다. 절대적인 개념은 아니다.

> [!NOTE] Queue 의 종류
> ![[Pasted image 20240217224503.png]]

> [!NOTE] 글로벌 큐의 서비스 품질 수준
> ![[Pasted image 20240218001933.png]]
> 외울 필요는 없고, 자주 사용하는 디폴트 글로벌큐를 기억한다. 필요하면 찾아서 사용하면 된다.
### GCD 사용시 주의해야할 사항 (177강)
> [!NOTE] GCD 사용 시 주의사항
UI, 즉 화면과 관련된 작업은 메인쓰레드에서 진행해야함.
 
> [!Tip] 컴플리션핸들러의 존재 이유 
> 비동기 처리는 작업을 시키고 바로 리턴을 하기 때문에 비동기적인 작업은 리턴을 하면 안된다.
### GCD사용시 주의해야할 사항(weak/strong 캡처 주의) (179강)
![[Pasted image 20240218151810.png]]
![[Pasted image 20240218152642.png]]
URLSession 은 내부적으로 비동기 처리가 되어있다.
### Async/await의 도입 (180강)
![[Pasted image 20240218154905.png]]
코드가 유지보수 하기 쉽게 바뀔 뿐더러, 리턴시점을 기다릴 수 있다.
### 동시성 프로그래밍 메모리 구조 / 동시성 프로그래밍의 문제점 (181강)
동시에 서로 다른 쓰레드에서 동시에 하나의 메모리에 접근했을 때 바로 경쟁상황(=경쟁조건)이라고 한다. (Thread-safe하지 않음)
![[Pasted image 20240218163545.png]]
데드락(교착상태)
![[Pasted image 20240218164659.png]]
### 동시성 프로그래밍 문제점의 해결 (182강)
경쟁상황에서 흔한 솔루션으로 동시큐로 보냈다가 메모리에서 접근할 때 시리얼큐로 접근하는 것이다. 하지만 상황에 따라 다르게 접근해야 한다.
![[Pasted image 20240218165002.png]]
 