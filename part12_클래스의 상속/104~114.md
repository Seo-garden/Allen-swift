### 상속의 기본 개념 (104강)
> [!NOTE] 상속이 뭐냐 ?
> 본질적으로 성격이 비슷한 타입을 새로 만들어 데이터(저장속성)을 추가(새로운 메모리 공간을 추가해서 찍어내는 것)하거나 기능(메서드)를 변형시켜서(재정의) 사용하려는 것.

> [!WARNING] 상속의 주의점 
> - 스위프트의 경우 다중상속을 지원하지 않는다.
> - final 키워드를 붙일 경우 상속을 금지해야 한다. 각 멤버 앞에 붙인 경우 해당 멤버 재정의 불가
> - 재정의를 하려는 멤버에는 override 키워드를 붙여야한다. (저장속성의 경우 재정의가 불가하다.)
### 클래스의 상속과 재정의 (105강)
*오버로딩 : 함수에서 함수의 하나의 이름을 여러 함수를 대응시켜서 사용    
오버라이딩 : 클래스의 상속에서 상위클래스의 속성/메서드를 재정의(기능을 약한 변형해서 사용)하는 것
> [!NOTE] 재정의가 가능한 대상(멤버)
> - 속성(하지만, 저장 속성에 대한 재정의는 어떠한 경우에도 불가능) / 데이터 구조의 변형은 불가
> - 메서드 (메서드, 서브스크립트, 생성자)
> ⭐️ 속성과 메서드는 재정의 방식이 다르다.
> 

> [!NOTE] 속성의 재정의(엄격)
> - 저장 속성의 재정의
> 	- 원칙적으로 불가능(고유의 메모리 공간은 유지 해야함) ==> 저장 속성은 고유 메모리 공간이 있으므로 하위클래스에서 고유의 메모리 공간을 바꾸는 방식으로의 재정의는 불가능
> 	- 메서드 형태로 추가하는 방식의 재정의는 가능 ==> 읽기/쓰기만 가능한 계산속성으로 재정의 가능(읽기만 가능한 계산 속성으로 정의 불가능 - 기능 축소는 불가능 X)
> 	- 속성 감시자를 추가는 가능하다(실질적 단순 메서드를 추가해서 저장 속성이 변하는 시점을 관찰할 뿐)
> - 계산 속성의 재정의
> 	- 실질적인 메서드이기 때문에 메서드 형태로의 재정의만 가능. 기능의 범위를 축소하는 형태로의 재정의는 불가능
> 	- (상위) 읽기전용 계산 속성을
> 	==> (하위)읽기/쓰기가 가능한 속성으로 재정의가능(확장O) 
> 	==> 속성감시자를 추가하는 재정의 가능(관찰은 가능)
> 	- (상위) 읽기/쓰기 계산 속성을
> 	==> (하위) 읽기만 가능한 속성으로만 재정의 불가능(기능 제한)
> 	==> 속성 감시자를 추가하는 재정의 가능 (관찰은 가능)
> 	
> 	

> [!NOTE] 인스턴스 속성의 대원칙⭐️
> - 저장 속성 재정의는 원칙적으로 불가능(하위 속성에서 상위 속성의 고유의 메모리 공간 변형 불가), 메서드 방식(계산 속성으로의 재정의 가능)으로 추가는 가능
> - 계산 속성의 유지/확장은 가능, 축소는 불가능
> - 속성 감시자(메서드)를 추가하는 재정의는 언제나 가능(실질적 단순 메서드 추가)
### 메모리 구조를 통한 이해 (106강)
> [!NOTE] 재정의 규칙 정리⭐️
>  - 저장 속성
> 	 - 저장 속성 재정의 불가
> 	 - 메서드는 정의 가능(메서드 형태로 부수적 추가는 가능, 메모리 구조를 건드리지 않는 형태로 가능)
> 		 - 읽기 / 쓰기 계산속성 형태로 재정의 가능(메서드 추가 형태로 구현)
> 		 - 속성감시자 형태로 재정의가능(실질적 단순 메서드 추가)
>  - 계산 속성(실질적 메서드)
> 	 - 계산속성의 재정의는 실질적 메서드 대체
> 	 - 확장 방식의 재정의 가능 
> 		 - 읽기 -> 읽기 / 쓰기 가능 (기능 확장 가능)
> 		 - 읽기 / 쓰기 -> 읽기는 불가능(기능 축소 불가능)
> 	 - 속성 감시자를 추가하는 재정의 가능(실질적 단순 메서드 추가)
>  - 생성자
> 	 - 기본적으로 상속되지 않고 재정의 원칙(생성자는 모든 저장 속성을 초기화하는 도구이기 때문에, 서브클래스에 최적화 되어 있지 있음)
> 	 - 상위의 지정생성자와 현재 단계의 저장 속성을 먼저 고려해서 구현⭐️
> 	 - 지정 생성자 : 재정의 필수(지정, 편의로도 가능) / 예외적 자동 상속
> 	 - 편의 생성자 : 재정의 불가(호출불가) / 예외적 자동 상속 
>  - 메서드
> 	 - 일반적으로 상위구현의 메서드를 대체 및 변형 할 수 있으므로, 자유롭게 재정의 가능(상위구현을 호출하는 경우도 많으니 주의)
### 초기화의 과정과 생성자 (107강)
> [!NOTE] 초기화란?
> 클래스, 구조체, 열거형의 인스턴스를 생성하는 과정

> [!TIP] 초기화의 방법(저장속성이 초기값을 가져야 함)
> - 저장 속성의 선언과 동시에 값을 저장
> - 저장 속성을 옵셔널로 선언 (초기값이 없어도 nil로 초기화된다)
> - 생성자에서 값을 초기화
> - 반드시 생성자를 정의해야만 하는 것은 아니다🙅

*원래 하던 적성적인 방법(이니셜라이저)으로 초기화를 하게 될 경우 여러 가지의 선택권을 주는 것과 같다.
> [!NOTE] 멤버와이즈 이니셜라이저 - 구조체의 특별한 생성자
> 구조체의 경우 저장속성을 초기화 하지 않아도 된다. 자동구현이 된다.
> - 구조체는 저장 속성들이 기본값을 가지고 있더라도, 추가적으로 멤버와이즈 이니셜라이저를 자동으로 제공한다
> - ⭐️ 개발자가 직접적으로 생성자를 구현하면, 멤버와이즈 이니셜라이저가 자동으로 제공되지 않음
> - 구조체에서만 선언된 저장 속성의 이름을 파라미터로 제공하기 때문에 멤버에 관한 생성자를 제공한다는 뜻에서 멤버와이즈 이니셜라이저라고 부른다.

> [!TIP] 왜 멤버와이즈 이니셜라이저를 제공할까?
> - 굳이 이유를 찾자면, 클래스보다 더 편하게 쓰기 위함으로 추측한다.
> - 앨런 뇌피셜, 클래스의 경우 생성자가 상속과 연관이 있기 때문이다.
### 생성자 (108강)
> [!NOTE] 클래스의 지정(Designated) vs 편의 생성자(Convenience)
> init() 이라고 붙은 생성자는 지정생성자
> - 지정 생성자는 모든 속성을 초기화 해야함
> 
> convenience init(){self.init()} 다른 생성자를 호출하는 편의생성자
>  - 편의생성자는 훨씬 더 편하게 인스턴스를 생성(지정생성자에 의존하는 방식)
>  - 편의생성자는 모든 속성을 초기화할 필요가 없음
>  
>  클래스는 상속을 지원하므로, 변수가 여러개이고, 여러 지정 생성자를 지원했을 때 상속 관계에서 개발자가 실수할 수 있는 여러가지 가능성이 있다. 
>  따라서 초기화 과정을 조금 간편하게 만들고, 상속관계에서 개발자가 실수 할 수 있는 여러가능성을 배제하기 위한 생성자다. 
>  모든 속성을 초기화 하지 않는다면 ==> 편의생성자로 만드는 것이 복잡도나 실수를 줄일 수 있다. 생성자의 가능한 중복을 없애고 다른 지정 생성자를 호출하는 패턴을 구현해야 한다.
*결론. (이미 모든 속성을 초기화하는 지정생성자가 있다면) 모든 속성을 초기화하지 않는 경우 편의생성자로 구현을 권장*

> [!Tip] convenience 를 붙이지 않고 init()을 구현할 때 값을 입력하면 되지 않냐?
> class 의 경우 상속을 할 때 재정의를 해야 하는데 내용이 많아지고 불편해지는 사항이 많아진다. 추후에 알려준다.

> [!NOTE] 구조체(값타입)의 지정생성자의 구현
> ⭐️구조체는 다른 생성자를 호출하는 방식도 가능 - init() {self.init()}

> [!NOTE] 클래스에서 상속이 일어나는 경우
> 	서브클래스에서 새로운 저장속성을 추가하고 초기화를 할 때 상위클래스의 저장속성과 함께 init(){} 를 해줘야 한다. 

	class A {
	    var x : Int
	    var y : Int
	    init(x: Int, y: Int) {
	        self.x = x
	        self.y = y
	    }
	    convenience init(){
	        self.init(x: 0, y: 0)
	    }
	}	
	class B : A {
	    var z : Int
	    init(x : Int, y : Int, z : Int) {
	        self.z = z      //필수
	        super.init(x: x, y: y)//필수 상위생성자 호출
	    }
	}

*지정생성자의 경우 반드시 재정의해줘야 한다. 편의생성자는 상속이 되지 않는 것이 원칙이다.* 
### 지정 생성자 / 편의 생성자 (109강) 다음에 또 보자
> [!NOTE] 지정생성자
> - init() 형태로 가지는 생성자
> - 지정생성자는 모든 저장 속성을 초기화해야함(저장속성의 선언과 동시에 값을 저장하거나, 저장 속성을 옵셔널 타입으로 선언하는 것도 가능)
> - 오버로딩이 가능하므로, 다양한 파라미터 조합으로 지정 생성자 구현 가능
> - 모든 저장 속성이 초기화 되는 경우, 기본생성자 자동 제공 -> init()
> - 생성자를 1개 이상 구현하면 기본 생성자를 제공하지 않음

> [!NOTE] 편의생성자
> - 지정생성자보다 적은 갯수의 파라미터로 보다 편리하게 생성하기 위한 서브개념의 생성자
> - 편의 생성자는 지정생성자의 의존 및 호출(지정생성자가 저장 속성 초기화)
> - 초기화 과정을 간편하게 제공하기 위함
> - 실질적으로 가능한 지정생성자의 갯수를 줄이고, 편의생성자에서 지정생성자 호출하도록 하는 것이 바람직함
> - 상속했을 때, 편의생성자의 경우 서브클래스에서 재정의를 못함(하위에서 호출불가가 원칙)
> - 편의생성자는 다른 편의생성자를 호출하거나, 지정생성자를 호출해야함
### 지정 생성자 / 편의 생성자 상속과 재정의 규칙 (110강)
*하위클래스는 기본적으로 상위클래스 생성자를 상속하지 않고, 재정의 하는 것이 원칙
(하위클래스에 최적화 되어 있지 않기 때문이다.) ==> (안전한 경우에만) 상위클래스의 생성자가 자동 상속됨*
> [!NOTE] 생성자는 기본적으로 상속되지 않고 재정의 원칙
> 상위 지정생성자와 현재 단계의 저장 속성을 고려해서 구현⭐️

> [!NOTE] 1단계
> - (상위)지정생성자 : 재정의 필수 고려(1. 지정, 2. 편의, 3.안할지) / 예외적 자동 상속  
> - (상위)편의생성자 : 재정의 불가(호출불가) / 예외적 자동 상속

> [!NOTE] 2단계
> - (현재단계의) 모든 저장 속성 초기화 및 상위의 지정 생성자 호출
> - (편의생성자 구현 시) 지정생성자를 호출
### 지정생성자 / 편의생성자 상속의 예외사항 (111강)
> [!NOTE] 예외 상황(생성자 상속되지 않음의 예외)
> - 지정생성자 자동상속 - 저장속성 기본값 설정 및 어떤 재정의도 안했을 때
> - 편의생성자 자동상속 - 상위지정생성자를 모두 상속하는 경우
> 	- (위의) 지정생성자 모두 자동상속의 경우
> 	- 상위의 지정생성자 모두 재정의 하는 경우
### 지정 생성자와 편의생성자의 이해 (111-1강)
> [!NOTE]
> 편의생성자는 직접적으로 메모리값을 세팅할 수 없다. 나의 지정생성자를 호출해서 더 적은 개수로 메모리를 찍어낼 수 있는 편의적인 생성자

> [!Warning] 만약 저장 속성이 옵셔널로 선언될 경우
> 데이터 값이 없어도 된다. 즉 이니셜라이저를 세팅해주지 않아도 된다.
### 필수(Required) 생성자 (112강)
> [!NOTE] 필수생성자
> - 클래스의 생성자 앞에 required 키워드를 붙이면 하위클래스에서 반드시 해당 생성자를 구현해야함
> - 하위클래스에서 필수 생성자 구현 시, override 키워드없이 required 키워드만 붙이면 됨
> - 필수생성자 자동상속 조건 : 다른 지정 생성자를 구현 안하면, 자동으로 필수생성자 상속됨⭐️
> -  하지만 지정생성자를 생성할 경우 자동상속조건을 벗어나서 필수생성자를 생성해야 한다.

> [!TIP] 필수생성자는 왜 필요한가?
> 애플이 미리 만들어놓은 프레임워크에는 필수 생성자가 있는 경우가 많다. 구현을 하지 않아도 자동으로 상속된다.
### 실패(Failable)가능 생성자 (113강)
> [!NOTE] 실패가능 생성자
> - 인스턴스 생성시, 실패가능성을 가진 생성자
> - 인스턴스 생성 실패 시 nil을 리턴
> - 생성자에 ? 를 붙여서, init?() 으로 정의(다만, 오버로딩으로 인한 구분이 안되므로, 해당이름을 가진 생성자는 유일한 생성쟈여야함)
> - 동일단계 / 상속관계에서의 호출
> 	- 실패 불가능 생성자는 다른 실패가능 생성자를 호출 불가능
> - 상속관계에서의 재정의
> 	- (상위)init? --> (하위) init (O)
> 	- (상위)init --> (하위) init? (X)

> [!TIP] 실패가능 생성자를 왜 만드는가 ?
>  실패가 불가능하게 만들어서, 아예 에러가 나고 앱이 꺼지는 가능성보다 실패가능 생성자를 정의하고 그에 맞는 예외 처리를 하는 것이 더 올바른 방법이기 때문이다.
### 소멸자(Deinitalizer) / 클래스, 구조체의 비교 (114강)
> [!NOTE] 소멸자(클래스에만 존재)
> - 인스턴스가 메모리에서 해제되기 직전 정리가 필요한 내용을 구현하는 메서드
> - 클래스 정의시 클래스에는 최대 1개의 소멸자를 정의가능
> - 소멸자는 파라미터를 사용하지 않음
> - 인스턴스가 메모리에서 제거되기 직전에 자동으로 호출됨⭐️

> [!Tip] 소멸자를 왜 구현하나 ?
> 특별한 작업을 수행중인 경우, 몇가지 추가 정리를 직접 수행해야 할 수 있음 ex) 인스턴스에서 파일을 열고 일부 데이터를 쓰는 경우, 클래스 인스턴스가 할당 해제되기 전에 파일을 닫아야 파일에 손상이 안갈 수 있음

> [!NOTE] 상속이 있는 경우
> - 상위클래스 소멸자는 해당 하위클래스에 의해 상속됨
> - 상위클래스 소멸자는 하위클래스 소멸자의 구현이 끝날 때 자동으로 호출됨
> - 상위클래스 소멸자는 하위클래스가 자체적인 소멸자를 제공하지 않더라도 항상 호출됨 
