### 클로저의 개념 및 1급 객체 취급의 의미 (142강)
*closure란 ? 이름이 없는 (익명)함수로 함수와 기능은 완전히 동일한데, 형태만 다르다고 생각하면 된다. ex)파이썬의 람다 -> 굳이 이름이 없어도 호출할 수 있는 형태로 사용 가능*
> [!NOTE] 스위프트는 함수를 "일급객체"로 취급 (함수도 타입이다)
> 함수는 타입이다
> - 함수를 변수에 할당할 수 있음
> - 함수를 호출할 때, 함수를 파라미터로 전달할 수 있음
> - 함수에서 함수로 반환할 수 있음
```
func aFunction(_ param : String) -> String {
	return param + "!"
}
var a : (String) -> String = aFunction1
a("안녕")
a = aFunction2    //딱히 구현을 하진 않았다. 새로운 함수를 담을 수 있지만, 동일한 타입이여만 가능
a("hello")
```
### 클로저의 형태 (143강)
플레이그라운드 참고.
```
let add = { (a1: Int, b1: Int) -> Int in
    let result1 = a1 + b1
    return result1
}
//타입추론이 가능한 경우
let add1 : (Int, Int) -> Int = {
(a,b) in
    let result = a + b
    return result
}
```
### 클로저를 사용하는 이유 (144강)
> [!Tip] 클로저는 왜 이름이 필요없을까? 
> 함수를 실행할 때 전달하는 형태로 사용하기 때문에 이름이 필요없음

> [!Tip] 클로저를 주로 쓰는 이유 
> 함수를 실행할 때 클로저를 정의하면서 전달하는 형태로 많이 쓰인다. 플레이그라운드 참고

*함수를 실행할 때 파라미터를 전달하는 함수 -> 콜백함수*
### 클로저를 사용하는 이유 - 2 (145강)
*미리 어떤 함수를 정의해놓고 그 함수를 사용한다는 것 보다 사후적으로 클로저 형태로 전달하면서 즉 클로저를 정의하면서 개발자가 만들고 싶은 함수를 정의할 수 있기 때문에 활용도가 늘어남(커스터마이징 가능)* - 플레이그라운드 참고
### 클로저의 문법 최적화 (146강)
> [!NOTE] 문법 최적화(간소화) - 플레이그라운드 참고
> - 문맥상에서 파라미터와 리턴밸류 타입 추론(Type Inference)
> - 싱글 익스프레션인 경우(한줄), 리턴을 안적어도 됨(Implicit Return)
> - 아규먼트 이름을 축약(Shorthand Arguments) ==> $0, $1
> - 트레일링 클로저 문법 : 함수의 마지막 전달 인자(아규먼트)로 클로저 전달되는 경우, 소괄호는 생략 가능
### 클로저의 실제 사용 예시 (147강)
플레이그라운드 참고.
### 클로저의 메모리 구조 (148강)
*함수의 직접적인 실행은 스택프레임에서 실행한다. 불변의 진리*
> [!NOTE] 클로저의 캡처
> 클로저에서 저장할 필요가 있는 외부의 어떤 값을 저장하거나 참조를 저장(주소를 저장)
### escaping / autoclosure 키워드 (149강)
*원칙적으로 함수의 실행이 종료되면 파라미터로 쓰이는 클로저도 제거됨*
> [!NOTE] @escaping
> 클로저를 제거하지 않고 함수에서 탈출시킴(함수가 종료되어도 클로저가 존재하도록 함) ==> 클로저가 함수의 실행흐름(스택프레임)을 벗어날 수 있도록 함

> [!Tip] @escaping 사용의 대표적인 이유
> - 어떤 함수의 내부에 존재하는 클로저(함수)를 외부 변수에 저장
> - GCD(비동기 코드의 사용)
> - Heap 영역에 저장해서 사용해야함 - 더 오래 유지할 필요가 있을 때

> [!NOTE] @autoclosure 
> - 일반적으로 클로저 형태로 써도 되지만, 너무 번거로울때 사용
> - 번거로움을 해결해주지만, 실제 코드가 명확해 보이지 않을 수 있으므로 사용을 지양(애플 공식문서)
> - 잘 사용하지 않음. 읽기 위한 문법
> - 기본적으로 non-escaping 특성을 가지고 있음
