# 클래스와 구조체

### 클래스와 구조체의 이해 (85강)

⭐️ 객체지향 프로그래밍

    class Dog {
        var name = "강아지"
        var weight = 0.0
    }

    var vori = Dog()
    vori.name = "보리"
    vori.weight = 8.0

⭐️ class 는 변수(=속성(property))와 함수(=메서드(method))로 구성할 수 있다.  
--> 반드시 2가지로 이루어진다. 

> [!NOTE] ⭐️ 클래스와 구조체는 크게 다르지 않다.  
> - 클래스와 구조체 둘다, 메모리에 찍어낸 것을 인스턴스라고 한다.
> - 인스턴스는 실제로 메모리에 할당되어 구체적 실체를 갖춘 것이라는 의미
> - 스위프트에서는 클래스의 인스턴스를 특별히 객체라고 부른다.



### 클래스와 구조체의 차이 / 메모리 / 복사 / let 선언 (86강)

> [!NOTE] ⭐️ 가장 큰 차이는 메모리 저장 방식의 차이 
> - struct
> 	- 값형식(Value Type)
> 	- 인스턴스 데이터를 모두 Stack 에 저장
> 	- ⭐️ (복사시) 값을 전달할 때 마다 복사본을 생성(다른 메모리 공간에 생성)
> 	- Stack 공간에 저장, 스택 프레임 종료 시, 메모리에서 자동으로 제거
> - class 
> 	- 참조형식(Reference Type)
> 	- 인스턴스 데이터는 Heap 에 저장, 해당 Heap 을 가리키는 변수는 Stack에 저장
> 	- 메모리 주소값이 Heap 을 가르킴
> 	- ⭐️ (복사시) 값을 전달하는 것이 아니고, 저장된 주소를 전달하기 때문에 동일한 데이터를 가리킨다.  
> 	- Heap 공간에 저장, ARC 시스템을 통해 메모리 관리(주의해야함)

⭐️ 클래스의 메모리 복사

    class Person { ⭐️
        var name = "길동"
        var age = 20
    }

    var aPerson = Person()
    aPerson.name = "에렌"
    print(aPerson.name)
    var bPerson = aPerson
    bPerson.name = "예거"

    print(aPerson.name) -> 예거 //메모리 주소가 복사되어 담겼기 때문에 결국 가리키는 녀석은 하나의 데이터다.
    print(bPerson.name) -> 예거

--> 결론적으로 구조체가 더 가볍기 때문에 많은 경우에 구조체를 사용한다고 생각하는게 편하다.  

> [!NOTE] 클래스와 구조체의 let 과 var
> - 클래스의 경우 인스턴스를 let 으로 선언해도 값이 변경되지만, 구조체의 경우 인스턴스를 let 으로 선언하면 값을 변경할 수 없다.
> - ⭐️ 구조체의 경우 let 으로 선언하면 원래 가지고 있는 속성(property)이 전부 let 으로된다. 메모리 구조가 Stack에 생기기 때문이다.
> - ⭐️클래스의 경우 let 으로 선언하면 let은 메모리 주소를 바꿀 수 없다.

⭐️ 클래스 내부에는 직접 메서드(함수) 의 실행을 할 수 없다.

### 초기화의 의미 (87강)

⭐️ 초기화(initializer) : 인스턴스를 만들 때 사용하는 특별한 메서드

    class Dog {
        var name1 : String
        var weight1 : Double
        init(name2: String, weight2: Double){
            self.name1 = name2
            self.weight1 = weight2
        }
    }

    var siba = Dog(name2: "시바견", weight2: 7.0)
    var choco = Dog(name2: "초코", weight2: 10.0)
> [!NOTE]
> - ⭐️ 모든 저장 프로퍼티(변수)를 초기화 해야함 (구조체, 클래스 동일함)
> - 생성자 실행 종료시점에는 모든 속성의 초기값이 저장되어 있어야 함(초기화가 완료하지 않으면 컴파일 에러)
> - 생성자의 목적은 결국 "저장속성 초기화"
> - ⭐️ 클래스, 구조체,(열거형)은 모두 설계도 일뿐이고, 실제 데이터(속성), 동작(메서드)을 사용하기 위해서는 초기화 과정이 반드시 필요하다.

### 초기화 관련 코드 / 클래스와 구조체의 차이 정리 (88강)

> [!NOTE] ⭐️ self 키워드는 클래스/구조체 내에서 해당 인스턴스(자기자신)을 가리킨다.
> - 인스턴스 내에서 동일한 변수명, 상수명을 사용할 때
> - 가리키는 것을 명확하게 하기 위해 self 키워드를 사용함

⭐️ 옵셔널타입을 가진 변수의 경우는 초기화값이 있을 필요는 없다 -> nil로 초기화되기 때문이다.

⭐️ 구조체와 클래스의 차이

| 구분           | 구조체                                                | 클래스                                          |
|:-------------- | ----------------------------------------------------- | ----------------------------------------------- |
| 타입           | Value Type                                            | Reference Type                                  |
| 메모리 관련    | 값의 저장 : Stack / 복사 전달                         | 값의 저장 : Heap /주소 전달(ARC로 관리)         |
| let / var 선언 | 인스턴스 상수로 선언시 저장 속성이 전부 상수로 선언됨 | 인스턴스 상수로 선언하면 가리키는 인스턴스 고정 |
| 생성자 관련    | 멤버와이즈 이니셜라이저 제공                          | 편의 생성자 존재                                |
| 메서드 + 속성  | 메서드 내에서 속성 변경 원칙적으로 불가능             | 메서드 내에서 속성 변경 가능                    |
| 소멸자         | 소멸자 없음                                           | 소멸자 있음                                     |
| 상속가능여부   | 상속 불가능                                           | 상속가능(클래스가 유일)                         |
실제 애플에서 반드시 필요한 경우가 아닌 경우 구조체를 사용하라고 권장하고 있다.

| 구분                  | 값 형식(구조체)                                               | 참조 형식(클래스)                                                          |
|:--------------------- | ------------------------------------------------------------- | -------------------------------------------------------------------------- |
| 타입                  | Value Type                                                    | Reference Type                                                             |
| 메모리 상의 저장 위치 | 필요시에 항상 메모리의 값이 복사되어 전달 / 값의 저장 : Stack | 필요시에 항상 메모리의 주소를 전달 / 값의 저장 : Heap(주소를 Stack에 저장) |
| 메모리 관리 방식      | 값이 들어있는 스택의 스코프가 종료되면 메모리에서 자동 제거   | RC(Reference Counting)을 통해 메모리를 관리 Swift 에서 사용하는 ARC 모델   |
| 각 형식의 타입예시    | 스위프트 기본 타입, 튜플, 열거형, 컬렉션, 구조체              | 클래스, 클로저                                                             |

### 클래스와 구조체 사용의 이유 / 객체지향의 4대 특징 (89강)
⭐️ 클래스와 구조체를 만드는 이유는 데이터를 묶음으로 만들려고 하는 것이다. 이러한 과정을 모델링이라고 한다.

> [!NOTE] ⭐️ 클래스나 구조체를 사용하는 이유 2가지
> 1. 사용하려는 모델의 설계 
> 	- Data Transfer Object(DTO) / VO : 관련 데이터를 한 곳에 담은 역할
> 	- Data Access Object (DAO) : 데이터 처리(비즈니스 로직)
> 	- Helper Object : 유틸리티(도움주는 기능 / 날짜, 시간, 통화, 인코딩)
> 2. 애플이 미리 설계해놓은 클래스/구조체들을 잘 사용하기 위함(프레임워크)

> [!NOTE] ⭐️ 언제 클래스/구조체를 사용해야 하는가 ?
> - 연관된 데이터들을 단순히 캡슐화(묶는)하는 것이 목적일 때 구조체 사용
> - 캡슐화한 데이터를 참조하는 것보다 복사해서 사용하는 것이 효율적일때 구조체 사용
> - 구조체에 저장딘 저장 속성들이 값 타입이며 참조하는 것보다 복사하는 것이 합당할 때 구조체 사용
> - 데이터에서 상속의 구조가 필요하면 클래스 사용
> - 해당 모델을 serialize 해서 전송하거나 파일로 저장할 경우가 발생하면 클래스 사용

⭐️ 필연적으로 클래스는 구조체보다 여러가지 면에서 속도가 느릴 수 밖에 없으므로 차이점을 명확하게 인지하고, 굳이 필요한 경우에만 클래스 사용

> [!NOTE] ⭐️ 객체지향의 4대 특징
> 1. 추상화(Abstraction) - [모델링]
> 	- 추상화란 실생활에서의 구체적인 것을 관찰자가 관심있는 부분만 가지고 재조합 하는 것
> 	- 실체들에서 관심있고, 공통적인 특성을 뽑아내서 하나의 분류로 만드는 것(모델링)
> 	- 객체지향의 관점에서, 실체들의 공통적 특성을 뽑아내서 클래스로 정의하는 것 자체가 추상화의 개념
> 	- ex) 도서관리프로그램 -> 제목 / 저자 / 출판사 등이 예시가 된다.
> 2. 캡슐화(Encapsulation) - [모델링 / 정보 은닉 / 데이터 캡슐화]
> 	- 연관이 있는 속성(상태)과 메서드(기능)를 "하나의 클래스"로 묶어서 활용한다는 개념
> 	- 묶을 때, 객체는 자신이 맡은 역할을 수행하기 위한 하나의 목적을 가진 실체라는 관점에서 접근해야함
> 	- 추상화와 밀접하게 연결되는 개념(추상화는 디자인 레벨 관점에서 바라보는 개념인데 반해, 캡슐화는 실제 코드로 구현하는 레벨에서의 개념)
> 	- 은닉화(information Hiding) : 캡슐화를 하면, 접근제어자(private, public 등)를 사용해 객체 외부에서 내부데이터의 접근 통제가 가능해진다.
> 3. 상속성(Inheritance) - [재사용/확장]
> 	- 부모클래스의 속성과 메서드를 자식클래스에서 그대로 물려받는 개념
> 	- 상속을 통해, 코드가 재활용되기 때문에 생산성이 높아짐(클래스의 재사용과 확장을 위해 상속이 사용된다)
> 	- 객체지향의 개념에서, 클래스가 다른 타입과 구별되는 결정적인 차별점
> 4. 다형성(Polymorphism) - [사용편의 / 동적바인딩]
> 	- 하나의 객체가 여러가지 타입의 형태로 저장될 수 있고, 다양한 메서드의 형태로 동작 가능함을 의미(하나의 객체는 부모의 타입으로도 저장이 가능하고, 프로토콜 타입으로도 저장이 가능)
> 	- 하나의 객체는 다양한 방식으로 동작 가능(동적 바인딩/Method Dispatch) (또한 오버라이딩과 오버로딩을 통해 하나의 메서드나 클래스를 다양한 방법으로 동작시키는 것을 포함하는 개념)
> 	
